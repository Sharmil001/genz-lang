---
import * as THREE from "three";
---

<div id="threejs-background"></div>

<script>
  import * as THREE from 'three';

  let container: HTMLElement | null;
  let camera: THREE.PerspectiveCamera;
  let scene: THREE.Scene;
  let renderer: THREE.WebGLRenderer;
  const spheres: THREE.Mesh[] = [];

  let mouseX = 0;
  let mouseY = 0;
  let windowHalfX = window.innerWidth / 2;
  let windowHalfY = window.innerHeight / 2;

  function init() {
    container = document.getElementById('threejs-background');
    if (!container) return;

    // Camera
    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.01, 100);
    camera.position.z = 10;

    // Scene
    scene = new THREE.Scene();

    // Environment map (cube texture)
    const loader = new THREE.CubeTextureLoader();
    const envMap = loader.load([
      '/textures/px.jpg', // right
      '/textures/nx.jpg', // left
      '/textures/py.jpg', // top
      '/textures/ny.jpg', // bottom
      '/textures/pz.jpg', // front
      '/textures/nz.jpg', // back
    ]);
    scene.background = envMap;

    // Sphere geometry
    const geometry = new THREE.SphereGeometry(0.5, 64, 32);

    // Reflective material
    const material = new THREE.MeshStandardMaterial({
      metalness: 1,
      roughness: 0,
      envMap: envMap,
    });

    // Create multiple spheres
    for (let i = 0; i < 100; i++) {
      const mesh = new THREE.Mesh(geometry, material);
      mesh.position.x = Math.random() * 20 - 10;
      mesh.position.y = Math.random() * 20 - 10;
      mesh.position.z = Math.random() * 20 - 10;
      mesh.scale.setScalar(Math.random() * 0.5 + 0.2);
      scene.add(mesh);
      spheres.push(mesh);
    }

    // Lights
    const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 1);
    hemiLight.position.set(0, 20, 0);
    scene.add(hemiLight);

    const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
    dirLight.position.set(-3, 10, -10);
    scene.add(dirLight);

    // Renderer
    renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    container.appendChild(renderer.domElement);

    animate();

    document.addEventListener('mousemove', onDocumentMouseMove);
    window.addEventListener('resize', onWindowResize);
  }

  function onWindowResize() {
    windowHalfX = window.innerWidth / 2;
    windowHalfY = window.innerHeight / 2;
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  }

  function onDocumentMouseMove(event: MouseEvent) {
    mouseX = (event.clientX - windowHalfX) / 100;
    mouseY = (event.clientY - windowHalfY) / 100;
  }

  function animate() {
    requestAnimationFrame(animate);

    const timer = 0.0001 * Date.now();
    camera.position.x += (mouseX - camera.position.x) * 0.05;
    camera.position.y += (-mouseY - camera.position.y) * 0.05;
    camera.lookAt(scene.position);

    for (let i = 0, il = spheres.length; i < il; i++) {
      const sphere = spheres[i];
      sphere.rotation.y += 0.01;
    }

    renderer.render(scene, camera);
  }

  if (typeof window !== 'undefined') {
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', init);
    } else {
      init();
    }
  }
</script>

<style>
  #threejs-background {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    z-index: -1;
    overflow: hidden;
  }

  #threejs-background canvas {
    display: block;
    width: 100% !important;
    height: 100% !important;
  }
</style>
